# ПРОГНОЗА ЗА ЦЕНИТЕ НА ЖИЛИЩА
## ПРОЕКТ по ВЕРОЯТНОСТИ И СТАТИСТИКА 

СУ - ФМИ - Зимен семестър 2024/2025
- Изготвил: Стоян Стоянов Иванов
- Специалност: Информатика, 3 курс, I група
- Факултетен номер: 9MI0400132

## 1. ЦЕЛ НА ПРОЕКТА:
Целта на този проект е да се извърши анализ на данни за жилища в Бостън с фокус 
върху предсказването на цената на имотите - променлива MEDV. Чрез едномерни и 
многомерни статистически методи се установят зависимостите между различни 
характеристики на жилищата и тяхната цена. 

Използваният набор от данни е "Boston House Pricing", който се поддържа от 
Университета Карнеги Мелън и е свободно достъпен за изтегляне.
Линк: (https://lib.stat.cmu.edu/datasets/boston)[https://lib.stat.cmu.edu/datasets/boston]



# Основно се обработват два файла: данни за жилища (housing.data) и съответните 
# имена на колоните (housing.names). Това е и информацията, съдържаща се в
# горния линк.

housing.df <- read.table("housing.data", header = FALSE, sep = "")

# read.table: Функция за четене на текстови файлове в R.
#   "housing.data": Името на файла с данни, който ще бъде прочетен.
#   header = FALSE: Указва, че файлът няма заглавен ред т.е. имена на колони.
#   sep = "": Указва, че разделителят между колоните е произволен брой празни 
#             места (празни интервали и/или табулации).
# Данните от файла housing.data се зареждат като data.frame в обекта housing.df

names1 <- read.fwf("housing.names", skip = 30, n = 17, widths = c(-7,8,-60))

# read.fwf: Функция за четене на файлове с фиксирана ширина на полетата.
#   "housing.names": Името на файла, от който ще се четат имената на колоните.
#   skip = 30: Пропускат се първите 30 реда от файла.
#   n = 17: Четат се само 17 реда от файла.
#   widths = c(-7, 8, -60): Указва ширината на полетата:
#     -7: Пропускат се първите 7 символа от всеки ред.
#     8: Извличат се следващите 8 символа от всеки ред. Те съдържат имената на 
#        колоните.
#     -60: Пропуска се остатъкът от реда.
# names1 съдържа извлечените имена на колоните с дължина 8 символа всяко, но те 
# все още може да съдържат допълнителни празни места.

names2 <- as.character(names1[-c(3,6,15),])

# as.character: Преобразува оставащите имена на колоните в символен вектор.

names2 <- gsub(" ", "", names2)
names(housing.df) <- names2

# Векторът names2 съдържа имената на колоните, след като са премахнати нежеланите 
# редове. След това замества празните интервали с нищо (т.е. премахва ги). Задава 
# имената на колоните в data.frame. Новите имена на колоните се присвояват на 
# housing.df. Така данните в housing.df вече имат описателни имена на колоните, 
# прочетени от файла housing.names.

any(is.na(housing.df))
summary(housing.df)

# is.na: Проверява дали даден елемент в таблицата е с липсваща стойност.
# any: Ако резултатът е TRUE, има липсващи стойности в housing.df. Ако е FALSE, 
# таблицата е без пропуски.

library(ggplot2)
ggplot(housing.df, aes(x = MEDV)) + geom_histogram(bins = 20, alpha = 0.5, fill = "purple")

# library(ggplot2): Зарежда библиотека за създаване на графики в R.
#   housing.df: Използваме таблицата като източник на данни.
#   aes(x = MEDV): Определя естетиката на графиката. В случая, x е колоната MEDV 
#     - това е зависимата променлива, която ще прогнозираме.
#   geom_histogram: Създава хистограма, която показва разпределението на 
#     стойностите.
#     bins = 20: Хистограмата ще бъде разделена на 20 интервала.
#     alpha = 0.5: Определя прозрачността на лентите.

# Бележка: Ако библиотеката не е инсталирана -> install.packages("ggplot2").

library(caTools)
set.seed(12345)

# library(caTools): Това е библиотека в R, която предоставя различни инструменти 
# за работа с данни.
# set.seed: Настройка за генериране на случайни числа. Това осигурява 
#   възпроизводимост, така че разделянето на данните да е винаги едно и също при
#   повторно изпълнение на кода.

# Бележка: Ако библиотеката не е инсталирана -> install.packages("caTools").

sample <- sample.split(housing.df$MEDV, SplitRatio = 0.7)

# sample.split: Използва се за случайно разделяне на данни.
#   housing.df$MEDV: Указва целевата променлива MEDV, която се използва за 
#     пропорционално разделяне.
#   SplitRatio = 0.7: Указва, че 70% от данните ще бъдат в тренировъчния набор, 
#     а останалите 30% ще са в тестовия набор.

train <- subset(housing.df, sample == TRUE)
test <- subset(housing.df, sample == FALSE)

# subset: Извлича подмножество от данните.
#   sample == TRUE: Указва, че искаме само редовете, маркирани като TRUE в 
#     логическия вектор sample.
#   sample == FALSE: Указва, че искаме само редовете, маркирани като FALSE в 
#     логическия вектор sample.

model <- lm(log(MEDV) ~ ., data=train) 
summary (model)

# lm: Функция за създаване на линеен регресионен модел в R.
# log(MEDV): Логаритмична трансформация на целевата променлива MEDV. Тази 
#   трансформация се използва, защото разпределението на MEDV е с отклонение 
#   вдясно (асиметрично), а логаритмичната трансформация спомага за 
#   нормализирането му.
# ~ .: Използват се всички останали колони в тренировъчния набор като независими 
#   променливи (предиктори).
# data = train: Данните за модела са тренировъчният набор train.

pred.lm <- predict(model,test)

# predict: Функция за извличане на прогнозите от създадения модел.
# pred.lm: Вектор с прогнозирани стойности за целевата променлива log(MEDV).

results <- cbind(pred.lm, test$MEDV)
colnames(results) <- c('Predicted', 'Actual')
results <- as.data.frame(results)
head(results)

# cbind: Комбинира два вектора (или матрици) колона по колона.
# results: Това е матрица, която съдържа две колони:
#   I. Прогнозирани стойности (pred.lm).
#   II. Реалните стойности на целевата променлива от тестовия набор (test$MEDV).
# as.data.frame: Преобразува матрицата results в data.frame за по-лесно 
#   управление и анализ.
# head: Показва първите 6 реда от results

# Изчисляване на коренната средноквадратна грешка (RMSE):

rmse.lm <- sqrt(sum((pred.lm - test$MEDV)^2)/length(test$MEDV))

# Измерване средното отклонение между прогнозираните и реалните стойности:
# pred.lm - test$MEDV: Разликата между прогнозираните и реалните стойности.
# (pred.lm - test$MEDV)^2: Квадратира разликите, за да се избегне компенсиране 
#   на положителни и отрицателни отклонения.
# sum: Сумира всички квадратирани разлики.
# length(test$MEDV): Броят на наблюденията в тестовия набор - n.
# sqrt: Изчислява корен квадратен от средната квадратична грешка.

# По-ниски стойности на RMSE означават, че моделът е по-точен.
# Колкото по-близо е R^2 до 1, толкова по-добре моделът обяснява зависимостта 
#   между променливите.

c(RMSE = rmse.lm, R2 = summary(model)$r.squared)

# c(): Комбиниране.

# 2. ЕДНОМЕРЕН АНАЛИЗ (X1, X2 и X3):
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
# Статистическа сума за X1 = 'CRIM' (Криминални престъпления):

summary(housing.df$CRIM)

# Визуализиране на разпределението на X1:

ggplot(housing.df, aes(x = CRIM)) + 
  geom_histogram(bins = 20, alpha = 0.5, fill = "purple") +
  labs(title = "Distribution of the Crime Rate", x = "Crime Rate", y = "Frequency")

# Статистическа сума за X2 = 'ZN' (% на земя за жилищно строителство):

summary(housing.df$ZN)

# Визуализиране на разпределението на X2:

ggplot(housing.df, aes(x = ZN)) + 
  geom_histogram(bins = 20, alpha = 0.5, fill = "purple") +
  labs(title = "Distribution of the Residential Land Zone", x = "Residential Land Zone", y = "Frequency")

# Статистическа сума за X3 = 'INDUS' (% на индустриални площи):

summary(housing.df$INDUS)

# Визуализиране на разпределението на X3:

ggplot(housing.df, aes(x = INDUS)) + 
  geom_histogram(bins = 20, alpha = 0.5, fill = "purple") +
  labs(title = "Distribution of Industrial Land Percentage", x = "Industrial Land Percentage", y = "Frequency")

# ggplot(): Основната функция в библиотеката ggplot2, която задава данните и 
#   визуализацията.
# geom_histogram(): -//-
# aes(x = A): Указва, че по ос X ще бъде използвана променливата A.
# labs(): Задава етикетите и заглавието на графиката.

# 3. МНОГОМЕРЕН АНАЛИЗ (Y = 'MEDV'):
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
# Линейна регресия на MEDV спрямо CRIM т.е. Y ~ X1:

model_crim <- lm(log(MEDV) ~ CRIM, data = housing.df)
summary(model_crim)

# Линейна регресия на MEDV спрямо ZN т.е. Y ~ X2:

model_zn <- lm(log(MEDV) ~ ZN, data = housing.df)
summary(model_zn)

# Линейна регресия на MEDV спрямо INDUS т.е. Y ~ X3:

model_indus <- lm(log(MEDV) ~ INDUS, data = housing.df)
summary(model_indus)

# lm(log(MEDV) ~ A, data = housing.df): Изграждане на линеен модел, който 
# предсказва log(MEDV) (цената на жилищата) въз основа на A = {X1, X2, X3}.
# log(MEDV) ~ A: Формула за линейна регресия, където MEDV е зависимата 
# променлива и A = {X1, X2, X3} е независимата променлива.

# 4. ПОСТРОЯВАНЕ НА ЛИНЕЕН МОДЕЛ:
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
# Създаване на многомерен линеен модел:

model_full <- lm(log(MEDV) ~ CRIM + ZN + INDUS + CHAS + NOX + RM + AGE + DIS + RAD + TAX + PTRATIO + B + LSTAT, data = housing.df)
summary(model_full)

# Изграждане на линеен модел, който предсказва log(MEDV) (цената на жилищата)
# въз основа на горните променливи.

# 5. ЗАКЛЮЧЕНИЕ:
# ‾‾‾‾‾‾‾‾‾‾‾‾‾
# Проектът включва анализ на данни за жилища с цел предсказване на цената на 
# имотите. Извършени са едномерен и многомерен анализ, които помогат да се
# идентифицират важни фактори, влияещи на цената на имотите. В рамките на 
# едномерния анализ се разглеждат разпределенията на променливите X1 = CRIM,
# X2 = ZN, и X3 = INDUS, като се установява, че всяка от тях има специфичен 
# ефект върху цената на имотите. Многомерният анализ позволява да изследва
# връзките между Y = MEDV и независимите променливи, като използваме линейни 
# модели. Посторен е многомерен линеен модел, който предсказва цената на имотите 
# въз основа на различни фактори. Резултатите показват значителни зависимости 
# между някои от тези променливи и цената на имотите.
